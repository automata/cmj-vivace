\documentclass[letterpaper, 12pt]{article}
\usepackage{cmjStyle}
\usepackage{natbib}
\bibpunct{(}{)}{;}{a}{}{,}
\doublespacing
\raggedright
%\setlength{\parindent}{0} % first para indent?
\setlength{\parskip}{2ex}
\parindent 24pt
\urlstyle{same} % make url tags have the same font
\setcounter{secnumdepth}{-1}

%% The package endfloat moves all floats (figures, tables...) to the
%% end of the paper, as required for the final version of a CMJ paper.
%% Leave this package commented out for initial submission, but
%% uncomment it for final version.
% \usepackage{endfloat}

% comandos uteis do ricardo
\newcommand{\note}[1]{\marginpar{\tiny\raggedright\textsf{\hspace{0pt}#1}}}
\newcommand{\inote}[1]{\textcolor{blue}{\texttt{\footnotesize[#1]}}}
\newcommand{\todo}[1]{\inote{TODO: #1}}

\begin{document}

%% %author - name
%% {\cmjAuthor Vilson Vieira, Renato Fabbri, Guilherme Lunhani, Geraldo Magela de Castro Rocha Junior}
%% %author - address
%% \newline
%% \begin{cmjAuthorAddress}
%%     Instituto de Física de São Carlos\\
%%     Universidade de São Paulo\\
%%     1234 Anywhere Street\\
%%     Anywhere, Anwhere 012345 USA\\
%%     vilson@void.cc, renato.fabbri@gmail.com, gcravista@gmail.com, gera.sp@gmail.com
%% \end{cmjAuthorAddress}

\vspace*{24pt}

%{\cmjAuthorPhone << AUTHOR TELEPHONE (not for publication): +55 16 8108 7007 >>}

 {\cmjTitle Vivace: A Collaborative Live Coding Language}

% outros títulos.. ??????????
% Vivace: Freak Coding on Your Face

\section*{Abstract}
This paper describes the principles and the design of Vivace,     
a live coding language built with Web technologies to be executed, idealy, in any ordinary brower. It starts by reviewing what 
motivated and inspired the creation of the language. That leads
to specifications of the language and how it is parsed and then executed using the recently 
created Web Audio API. A brief discussion is them posed on
why the Web is an  
environment of interest to collaborative live coding and how it
affected the performances. This work concludes by previewing how Vivace has
motivated the creation of "Freak Coding", a live coding sub-genre.

\section*{} % Introdução, sem título.

This paper describes the principles and the design of Vivace,     
a live coding language built with Web technologies to be executed, idealy, in any ordinary brower. It starts by reviewing what 
motivated and inspired the creation of the language. That leads
to specifications of the language and how it is parsed and then executed using the recently 
created Web Audio API. A brief discussion is them posed on
why the Web is an  
environment of interest to collaborative live coding and how it
affected the performances. This work concludes by previewing how Vivace has
motivated the creation of "Freak Coding", a live coding sub-genre.
\section*{} % Introdução, sem título.
In November of 2011, a live coding trio called \textit{FooBarBaz}
unleashed it's first presentation for a wide
audience, it's performers were using two instances of ChucK and
a dedicated mixing PD+Analog Mixer instance~\footnote{Pictures of the presentation are available at
\url{http://www.flickr.com/photos/festivalcontato/6436260557}}. Live
coding is becoming popular world wide while remaining quite untouched in
Brazil. As far as we know, this presentation was the first live coding
performance in our country. In that day an audience between 3000-5000
attendees were in the audience of the performance
were code was used to create the music they were listening. At
same time, the two live coding desktop workspaces were projected on big screens to the public.
During the performance, the trio used ChucK~\cite{wang2003chuck} in an
uncommon way. Instead of writing loops and conditionals, one of the live coders
manipulated parameters of audio files by editing lists of numerical
values together with mnemonic operations like retrograde, transposition.
The other live coder focused on more fluid lines with large sounds with
evolving characteristics, this contributed with larger musical archs.
Audio mixing with
Puredata was done by one of the performers using literally his hands tracked by
a camera and color detection based algorithms. Live coder used code templates quick-inserted by editors (Vi and Emacs). Other visual resources the performers focused
on are: cowsay phrases on individual terminals and REM-like bouncing balls. These artifacts - code, cowsay phrases, moving REM-like points of reference, all projected in big screens to the public - were incorporated as good practices during the live coding performance.
Therefore, based on those elements, a new language was designed:
Vivace~\footnote{A live demonstration of
    Vivace is online at \url{http://vivace.void.cc} ready to be used by
everyone using Google Chrome or Safari.}~\cite{Vivace}.
To avoid software
configuration and make it easy to share the session -- and the system
itself -- with everyone, the Web was choosen as the running
environment for Vivace. On every new session performed using
Vivace, new principles were added into the language and, at the same
time, into our artistic behaviour.
In summary, this paper is a circle: it describes how performances
motivated the language and how the language itself influenced the
creation of a live coding genre that is being developed by many hands,
called ``Freak Coding'' by it's manifesto, other written resources, and
in spoken instances.

\parskip 18pt

\section{Motivation \& inspiration: arrange the room, the code is dirty}
Vivace is inspired by various live coding languages. The sintax of
Vivace, as shown in Figure~\ref{fig:vivace}, borrows elements from ixi
lang~\citep{magnusson2011ixi} like the use of sequences to control
audio parameters in real time. ABT~\citep{fabbri} and
FIGGUS~\citep{fabbri2} were tightly important to the development of
Vivace as well and we are planning to rewrite some of its components
-- originally in Python -- inside Vivace. ChucK 
suggested chained unit generators specified by the $=>$ operator,
imitating the object connections in visual programming languages like
Puredata.

\begin{figure}[htpb]
  \begin{center}
    \includegraphics[scale=.3]{img/fig_vivace.png}
    \caption{The Vivace environment}
    \label{fig:vivace}
  \end{center}
\end{figure}

After the creation of Audio Data
API~\citep*{audiodata} and the most recent Web Audio API~\citep*{webaudio}
-- that makes possible to process audio in real time inside Web
browsers -- a collection of audio Web applications started to
merge. The same is true for live coding languages and systems.
Thus, along with the \textit{desktop languages} pointed above,
Vivace was also inspired by
Web live coding languages and
is part of this \textit{family} of Web applications together with
Gibber~\citep*{gibber}, livecoder~\citep*{livecoder},
livecoding.io~\citep*{livecodingio} and livecodelab~\citep*{livecodelab},
to note some of them. 

A remarkable difference between Vivace and those languages or
environments is the collaborativity. Vivace was built to make possible
to write code with many hands at the same time, as happens with the
now popular "pads"\footnote{Etherpad on: \url{http://etherpad.org/}.},  a characteristic easily implemented on Web.
Another difference is the unconcern to be a
Turing-complete language. This made the design of Vivace more
flexible and near to the music process instead of the computing
process (a characteristic perceived in ixi lang as well). Vivace tries
to place itself between the rigorous of code and the flexibility of
artistic expression.


\section{The language we all speak}
Vivace, as a language\footnote{The complete language specification can
    be found at \url{https://github.com/automata/vivace/wiki/Language-spec}.},
    is a
collaborative live coding language with use of extreme simple language
syntax, mnemonic actions, easy audio mixing, template editing and
audio parameters automation. The use of shared
code, sounds and images leads to a more complex scenario, thus greater
the possibility of inconsistency of compiled code as well as actions
for artistic result. This enhances the the fit of specific language
syntaxes.

Vivace is not an imperative language. Instead of routines and
procedures to control audio attributes, it uses definitions
related with musical
scores and the \emph{track paradigm} common on music production
software. It is natural to musicians (and, as we experienced
during performances, also to non-musicians) to understand a sequence
of notes, or audio parameters, repeating over and over again, than a
for-loop and if-chains. In this way, Vivace is a declarative, domain
specific language, based on the following principles:

\begin{itemize}
  
\item Names are something like $a$, $b$, $c$ and are defined as the user wants.
\item Music is made by voices (instruments).
\item Voices have name, timbre and parameters changing along the
  time.  
\item The language should be simple. ``Freak coders'', with a dedicated section below,
   only define some properties with a set
  of values (i.e. arrays, dictionaries) making it possible to generate
  sequences, even using list comprehension.
\item Mnemonic musical operations (reverse, inverse, transpose)
  on properties by use of syntax sugar: few chars, big
  results.
\item Timbre are signals made by chains of audio generators and
  filters or video files as described below.
\item Parameters are musical notes, amplitudes, oscillators frequency,
  delay time and so on.
\item Parameters changes their values at specific times and during
  certain durations.

\end{itemize}

Here is a ``Hello, World!'' Vivace code. A voice is defined as
\textit{foo} and its parameters are specified using the \textit{dot}
operator. Every parameter changes over time as the values
written as numerical sequences, surrounded by brackets. A special
sequence exists to every parameter.
This is all the Vivace syntax.

\begin{Verbatim}[fontfamily=courier, xleftmargin=\parindent]
  # foo is a simple audio sample, oscillator or video file
  foo.src = youtube('http://www.youtube.com/watch?v=XXX')
  # defining the video positions (in seconds) to be played
  foo.pos = [10, 20, 35]
  # the durations (as time ratios) to play each position
  foo.cgur = [1/2, 1/4, 1/8, 1/16, 1]
\end{Verbatim}

There are extra semantics to operate on the sequences. Every sequence
accepts operators: mnemonic commands used to reverse, transpose and
even replace elements of the sequence based on list
comprehensions. Those operations are common in music composition and
having them as mnemonics makes typing fast and handy for live
coding. The next listing presents the standard operators.

\begin{Verbatim}[fontfamily=courier, xleftmargin=\parindent]
# we can use operators
foo.pos = [1, 2, 3] reverse        # result is [3, 2, 1]
foo.pos = [1, 2, 3] inverse        # result is [1, 0, -1]
foo.pos = [1, 2, 3] transpose +2   # result is [3, 4, 5]

# and even list comprehension
foo.pos = [1/i+1 for i in [1, 2, 3]] 
# result is [2, 3, 4]

# or combine both
foo.pos = [1/i+1 for i in [1, 2, 3]] reverse 
# result is [4, 3, 2] as expected
\end{Verbatim}

Vivace is written in JavaScript to take advantage of Web technologies.
To parse Vivace, Jison~\citep*{jison} comes handy, a JavaScript library that
clones Flex and Bison functionalities as lexer and parser. This
flexibility to parse and execute new languages as JavaScript inside
every browser opens a remarkable oportunity to experiment with new
sintaxes and semantics for live coding. Furthermore, considering Web
was always strong on UI development thanks to HTML and CSS, one can
experiment those new languages with fast prototyped UI. Along these
advantages, it is important to note: every live coding
language built on Web runs everywhere a browser is installed. No
firewall chain to surpass with OSC, no software installation and
configuration, no dependencies, people just need to type an URL.

\section{The audio engine}
\label{audioengine}

Before Web Audio API, the only way to create sound in web pages was
using plugins. Recently, Web Audio API enabled real time audio
processing on Web browsers\footnote{At the time this paper was written,
only Google Chrome and Apple Safari supported the API. Mozilla is
working to have it running on Firefox as well.}. Every routine is
writen as native code (in C++ and Assembly when needed) to guarantee
maximum performance. The API is based on a convenient and familiar
paradigm: audio unit graphs. Web Audio specifies a collection of nodes
(AudioNode objects) and routines to connect and disconnect them. While
manipulating those nodes we can create a large number of audio
applications: synthesizers, filters, analysers, mixers and even real
time audio engines to live coding. This motivated basic explorations
of multichannel expansion, filtering and audio effects,
controling an integrated Web audio system.

Every voice in Vivace is represented as a default audio chain such
as the one shown
in Figure~\ref{fig:chain}. All audio unit parameters within this
chain (e.g. pitch, reverb time, high, medium and low channel levels,
panner values and gain) can be manipulated editing the code or by
sliders on a UI (Figure ~\ref{fig:ui}). This kind of interface is more
familiar to musicians, remembering a real mixer, and makes possible an
adequate treatment of voices timbre and spacialization of the
sound sources by means of parameters like level of stereophonics channels L
and R, quality, central frequenfy and gain of a 3-band equalization filter,
and reverb time control.

\begin{figure}[htpb]
  \begin{center}
    \includegraphics[scale=.5]{img/fig_chain.png}
    \caption{Standard audio unit chains as Web Audio API objects for
      each Vivace voice.}
    \label{fig:chain}
  \end{center}
\end{figure}

\begin{figure}[htpb]
  \begin{center}
    \includegraphics[scale=.3]{img/fig_ui.png}
    \caption{Every audio unit parameter can be manipulated by code or
      using the UI.}
    \label{fig:ui}
  \end{center}
\end{figure}

Vivace supports every audio unit supported by Web Audio API. It is
possible to load audio files or synthesize in real time using
wavetable oscillators. The default audio chain of each voice can be
modified at any time while it is running. It is interesting to note
the presence of an ``Analyser'' inside the default chain. It uses FFT
(natively implemented) to expose energies and frequencies, 
enabling the use of those values to animate videos and render forms
inside Vivace.

Along with audio, Vivace supports video files. It is possible
to upload files or use YouTube URLs. Videos are treated the same way
as buffer sources or oscillators, i.e. as voices, and can be manipulated on
real time, making Vivace a live cinema or a VJing tool.

\section{Into the wild: making it collaborative}\label{sec:freakcoding}

Vivace as a tool enables interaction while everyone could use
its own creativity. The interaction is not 
mediated by a common score, but by a mutual desire
to create a composition in real time. In this context
borns the \emph{Freak Coder} (Figure~\ref{fig:freakcoder}): someone that adds
up his individuality to others aiming to transform the computer in an
instrument of artistic fruition without restricting to itself the control of the
machine but inviting everyone to join him in the
same activity. A freak coder decides what he is going to do and amplifies his own
comprehension of the computer's capacity as an instrument. By using simple
rules, Vivace enables the emergence of the performance and makes it a
kind of a collective game, where the rules, being visible to everyone,
eases audience and specialists alike to join in.

\begin{figure}[htpb]
  \begin{center}
    \includegraphics[scale=.4]{img/fig_freakcoder.png}
    \caption{Freak Coder}
    \label{fig:freakcoder}
  \end{center}
\end{figure}

Live Coding becomes a natural path to the type of use and
technological development in which freak coders are envolved, 
in confluence with the understanding that technology should never be
treated as a dogma or kept in secret. Live coding is seen as a
behavioral disalienation
of a digital artist. Not only the code is displayed and
manipulated, but the computer screen and potentially any interaction between the
performance and the computer. The triad performancer, computer code and
audience characterises the performance as Live
Coding.
This comprehension was possible after a presentation by LabMacambira.sourceforge.net
at the 9th edition of AVAV (\textit{\'{A}udioVisual Ao Vivo} or Live
Audiovisual), an event where artists who are experimenting audio and
video in real time comes together to show their works. In this
presentation Caleb Luporini and Gera Rocha started without Renato
Fabbri and Vilson Vieira, as they were on their way to the presentation,
traveling from another city. Upon arrival, they both turned their
laptops on and stated taking part on the performance in such a way
that no embarrassment or rupture was brought into the happening.
It is important to state that no previous rehearsal had taken place between
Mr. Luporini and Mr. Rocha\footnote{Videos were selected beforehand by Mr. Luporini
alone without knowledge of the other performers.}. In the 30 minutes
performance, the audience started to take guidence from messages given
on the performance's big screen and edited Vivace code that was being
played together with the starting four performers.



%Outra característica que emergiu dessa apresentação foi a capacidade
%de mesmo em um ambiente 'formal' de apresentação - os quatro
%performers estavam em uma sala escura, três virados para o telão e um
%virado para o público, que estava em cadeiras organizadas como em um
%teatro - gerar um estado de euforia coletiva. É importante a reflexão
%sobre como a soma entre máquina e humano gera esse estado. É a
%postura do performer diante do computador que tira aquele que deveria
%apenas assitir desse lugar e possibilita que uma experiência que é
%altamente técnica no que se refere ao desenvolvimento tecnologico do
%qual é origem tornne-se assimilável e lúdica. Durante toda a
%apresentação todos os integrantes do Lab Macambira riam entre si e
%estabeleciam uma relação com o público que era de leveza e
%fraternidade, isto é, o público era constantemente convidado pela
%postura do Lab Macambira a interagir com o que estava sendo proposto
%ali. Essa troca entre os quatro elementos ali presentes - performers,
%computador, Vivace, público - são capazes de criar um ambiente de
%colaboração e liberdade geradores de ludicidade e conhecimento
%realmente inéditos, pelo menos no que se refere a Live Code feito no
%Brasil. É, como explicado acima, a esse 'facilitador' que emergiu que
%passamos a chamar de Freak Coder.

%Todos integrantes do Lab Macambira são originários dos movimentos de
%software livre brasileiros. E é aí onde primeiramente devemos buscar
%pistas da origem do Freak Coder, que um programa com as
%características do Vivace possibilitou emergir. É totalmente inerente
%ao movimento do software livre a transmissão continua daquilo que se
%sabe. Assim como a desmistificação da tecnologia e o comportamento
%festivo e gregário.

%No ponto performer/computador é onde esse devir se concretiza. Mais
%do que o conteúdo utilizado no Live Coding a postura do performer em
%relação ao computador, como ficou explicito na apresentação supra
%citada, é o que subverte não só a utilização do computador mas a
%relação entre homem e máquina. Isto é, uma postura 'rock and roll'. O
%freackcoder rompe, por sua própria natureza, com o estigma do
%computador como canalizador de uma postura séria e
%profissionalesca. Assim como rompe com a postura do performer erudito
%sisudo e fechado em si. O freakcoder é rock and roll. O Freakcoder
%torna-se o Jerry Lee Lewis da tecnologia, fazendo tecnopirofagia. O
%freakcoder consegue programar e sorrir ao mesmo tempo. O Freakcoder
%'seduz' através do monitor do computador e através do jeito que
%programa.

\begin{figure}[htpb]
  \begin{center}
    \includegraphics[scale=.3]{img/fig_novela.png}
    \caption{Videos from popular Brazilian novels were used as
      material: extreme pop-art.}
    \label{fig:novela}
  \end{center}
\end{figure}




\section{Conclusions}

%Carnaval, uma proposta de "canal de TV pessoal" baseado em Vivace.

%Interface com WebGL para novas GUIs e renderização de objetos 2D/3D, textos.

%Freakcoding como um subgênero de livecoding: cravo, aqui seu
%manifesto poderia entrar forte ;-)

\todo{Escrever...}

\bibliographystyle{cmj}
\bibliography{cmjbib}
\end{document}
